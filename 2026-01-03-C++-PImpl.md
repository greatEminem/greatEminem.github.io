---
layout:     post
title:      Pimpl模式
subtitle:   C++ Pimpl模式
date:       2026-01-03
author:     HDW
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
    - C++
---

#### Pimpl模式介绍

Pimpl(Pointer to Implementation)，也称为**编译防火墙**，其核心思想是：

**将类的实现细节（私有成员）隐藏在一个不透明的指针的背后，这个指针指向一个在头文件中只有前向声明的实现类**

A.h
```
class A {
public:
    A ();
    ~A();
    A(A&&);
    A& operator=(A&&);

    void  doSomething();
private:
    class Impl;
    std::unique_ptr<Impl> m_pImpl;
};
```

A.cpp
```
#include <vector>   // 这些以来只在cpp中感知

class A::Impl {
public:
    std::string m_name;
    std::vector<int> m_data;
};

A::A():m_pImpl(std::make_unique<Impl>()) {}

A::~A() = default;  // 必须在Impl完整定义之后，否则unique_ptr析构会出错

A::A(A&&) = default;    // 同样需要完整Impl定义

A& A::operator=A(A&&) = default;    // 同样需要完整Impl定义

void A::doSomething() {
    m_pImpl->m_data.push_back(1);
}

```
#### Pimpl模式的优点
1. 隐藏实现细节，降低编译依赖，你的代码作为第三方库使用时，用户代码中只包含你的头文件，当你修改Impl的私有成员时只需要编译你的库文件，用户的代码完全不需要编译；
2. 提高接口稳定性，内部重构私有实现不会导致头文件发生变化

#### Pimpl的缺点及注意事项
1. 每个对象都需要额外分配一块堆内存来存放Impl对象
2. 实现更复杂
 - 需要编写额外的代码来管理Impl的生命周期；
 - std::unique_ptr需要在其析构时看到Impl的完整类型，而编译器默认生成的特殊成员函数可能无法满足这一点。

Pimpl是一种通过牺牲少量运行时性能和增加实现复杂性，来换取巨大的编译时效益和接口稳定性的惯用法。
